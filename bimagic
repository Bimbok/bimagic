#!/bin/bash

echo "Welcome to the Git Wizard! Let's work some magic..."
echo

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Sound functions
play_sound() {
  local sound_type=$1
  case "$sound_type" in
  "success")
    # Pleasant bell sound
    echo -e "\a" # System bell
    # Alternative: play a beep sequence
    for i in {1..2}; do
      printf "\a"
      sleep 0.1
    done
    ;;
  "error")
    # Harsher error sound
    for i in {1..3}; do
      printf "\a"
      sleep 0.05
    done
    ;;
  "warning")
    # Single warning beep
    printf "\a"
    ;;
  "magic")
    # Magical sequence for special operations
    for i in {1..3}; do
      printf "\a"
      sleep 0.2
    done
    ;;
  "progress")
    # Subtle progress indicator
    printf "\a"
    ;;
  esac
}
print_status() {
  echo -e "${GREEN}[INFO]${NC} $1"
  play_sound "success"
}

print_error() {
  echo -e "${RED}[ERROR]${NC} $1"
  play_sound "error"
}

print_warning() {
  echo -e "${YELLOW}[WARNING]${NC} $1"
  play_sound "warning"
}

# Function to get current branch with color
get_current_branch() {
  git branch --show-current 2>/dev/null || echo "main"
}

# Function to display branches with fzf
show_branches() {
  local current_branch=$(get_current_branch)

  # Get all branches and highlight current one
  git branch -a --format='%(refname:short)' |
    while read -r branch; do
      if [[ "$branch" == "$current_branch" ]]; then
        echo -e "${GREEN}âž¤ $branch${NC} (current)"
      else
        echo "  $branch"
      fi
    done | sort -u
}

# show_repo_status() {
#     if ! git rev-parse --git-dir >/dev/null 2>&1; then
#         print_warning "Not inside a git repository!"
#         return
#     fi

#     local branch=$(get_current_branch)

#     # Ahead/behind info
#     local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
#     local ahead behind
#     if [[ -n "$upstream" ]]; then
#         ahead=$(git rev-list --count "$upstream"..HEAD 2>/dev/null)
#         behind=$(git rev-list --count HEAD.."$upstream" 2>/dev/null)
#     else
#         ahead=0
#         behind=0
#     fi

#     # Working tree status
#     if git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null; then
#         if git ls-files -u | grep -q .; then
#             status="ðŸ”´ ${RED}conflicts${NC}"
#             color=$RED
#         else
#             status="ðŸŸ¢ ${GREEN}clean${NC}"
#             color=$GREEN
#         fi
#     else
#         status="ðŸŸ¡ ${YELLOW}uncommitted${NC}"
#         color=$YELLOW
#     fi

#     echo
#     echo -e "${color}===== REPO STATUS =====${NC}"
#     echo -e "GITHUB USER: ${GREEN}$GITHUB_USER${NC}"
#     echo -e "BRANCH: ${GREEN}$branch${NC}"
#     echo -e "AHEAD: $ahead | BEHIND: $behind"
#     echo -e "STATUS: $status"
#     echo -e "${color}=======================${NC}"
# }

show_repo_status() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    print_warning "Not inside a git repository!"
    return
  fi

  local branch=$(get_current_branch)

  # Ahead/behind info
  local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
  local ahead behind
  if [[ -n "$upstream" ]]; then
    ahead=$(git rev-list --count "$upstream"..HEAD 2>/dev/null)
    behind=$(git rev-list --count HEAD.."$upstream" 2>/dev/null)
  else
    ahead=0
    behind=0
  fi

  # Working tree status
  local status
  if git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null; then
    if git ls-files -u | grep -q .; then
      status="ðŸ”´ conflicts"
      # status_colored="ðŸ”´ ${RED}conflicts${NC}"
      color="$RED"

    else
      status="ðŸŸ¢ clean"
      # status_colored="ðŸŸ¢ ${GREEN}clean${NC}"
      color="$GREEN"
    fi
  else
    status="ðŸŸ¡ uncommitted"
    # status_colored="ðŸŸ¡ ${YELLOW}uncommitted${NC}"
    color="$YELLOW"
  fi

  # Lines WITHOUT color (for width calc)
  local line1="GITHUB USER: $GITHUB_USER"
  local line2="BRANCH: $branch"
  local line3="AHEAD: $ahead | BEHIND: $behind"
  local line4="STATUS: $status"

  # Find max width
  local maxlen=0
  for l in "$line1" "$line2" "$line3" "$line4"; do
    [[ ${#l} -gt $maxlen ]] && maxlen=${#l}
  done
  local border_len=$((maxlen + 5))
  ((maxlen += 3))
  # Print fancy box
  echo
  echo -e "${color}â•­$(printf 'â”€%.0s' $(seq 1 $border_len))â•®${NC}"
  printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" "$maxlen" "$line1"
  printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" "$maxlen" "$line2"
  printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" "$maxlen" "$line3"
  # Print STATUS with colors
  printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" "$((maxlen + 2))" "$line4"
  echo -e "${color}â•°$(printf 'â”€%.0s' $(seq 1 $border_len))â•¯${NC}"
}

generate_bar() {
  local percentage=$1
  local bar=""
  # Convert float to integer for bar calculation
  local int_percentage=${percentage%.*}
  local bars=$((int_percentage / 2)) # Each â–ˆ represents 2%

  for ((i = 0; i < bars; i++)); do
    bar+="â–ˆ"
  done
  echo "$bar"
}

# Function to get contributor statistics
show_contributor_stats() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    print_error "Not a git repository!"
    return 1
  fi

  # Time range selection
  local time_range=$(printf "%s\n" \
    "Last 7 days" \
    "Last 30 days" \
    "Last 90 days" \
    "Last year" \
    "All time" |
    fzf --prompt="Select time range: " --height=10 --border --ansi)

  local since=""
  case "$time_range" in
  "Last 7 days") since="--since='7 days ago'" ;;
  "Last 30 days") since="--since='30 days ago'" ;;
  "Last 90 days") since="--since='3 months ago'" ;;
  "Last year") since="--since='1 year ago'" ;;
  "All time") since="" ;;
  *)
    print_warning "No time range selected."
    return 1
    ;;
  esac

  print_status "Analyzing contributions ($time_range)..."
  echo

  # Temporary file for processing
  local temp_file=$(mktemp)

  # Get git log with numstat and format for processing
  if [[ -n "$since" ]]; then
    eval "git log --pretty=format:'%aN' --numstat $since" >"$temp_file" 2>/dev/null
  else
    git log --pretty=format:"%aN" --numstat >"$temp_file" 2>/dev/null
  fi

  # Check if we got any data
  if [[ ! -s "$temp_file" ]]; then
    print_error "No contribution data found for the selected period."
    rm -f "$temp_file"
    return 1
  fi

  # Process the data with awk
  local stats=$(awk '
    BEGIN {
        total_lines = 0
    }
    /^[0-9]/ {
        added = $1
        deleted = $2
        if (added != "-") total_added += added
        if (deleted != "-") total_deleted += deleted
        author = last_author
        if (author != "") {
            author_lines[author] += added + deleted
            total_lines += added + deleted
            author_commits[author]++
        }
    }
    !/^[0-9]/ && !/^$/ {
        last_author = $0
        if (!author_commits[$0]) {
            author_commits[$0] = 0
        }
    }
    END {
        for (author in author_lines) {
            if (total_lines > 0) {
                percentage = (author_lines[author] / total_lines) * 100
            } else {
                percentage = 0
            }
            printf "%s|%d|%d|%.1f\n", author, author_lines[author], author_commits[author], percentage
        }
    }' "$temp_file" | sort -t'|' -k2 -nr)

  rm -f "$temp_file"

  if [[ -z "$stats" ]]; then
    print_error "No contribution data found for the selected period."
    return 1
  fi

  # Calculate additional metrics
  local most_active_author=""
  local most_commits=0
  local most_productive_author=""
  local highest_avg=0

  # Display header
  echo -e "${PURPLE}Contribution Report ($time_range)${NC}"
  echo "$(printf 'â”€%.0s' $(seq 1 45))"

  # Display each contributor
  while IFS='|' read -r author lines commits percentage; do
    # Clean up author name
    author=$(echo "$author" | sed 's/^ *//;s/ *$//')

    # Generate bar (max 50 characters for 100%)
    local bar=$(generate_bar "$percentage")

    printf "%-15s %-25s %5.1f%% (%d lines)\n" \
      "$author" "$bar" "$percentage" "$lines"

    # Track most active (most commits)
    if [[ $commits -gt $most_commits ]]; then
      most_commits=$commits
      most_active_author="$author"
    fi

    # Track most productive (highest average lines per commit)
    if [[ $commits -gt 0 ]]; then
      local avg_lines=$((lines / commits))
      if [[ $avg_lines -gt $highest_avg ]]; then
        highest_avg=$avg_lines
        most_productive_author="$author"
      fi
    fi

  done <<<"$stats"

  echo
  echo -e "${CYAN}Highlights:${NC}"
  if [[ -n "$most_active_author" ]]; then
    echo -e "${BLUE}Most Active:${NC} $most_active_author ($most_commits commits)"
  fi
  if [[ -n "$most_productive_author" ]]; then
    echo -e "${BLUE}Most Productive:${NC} $most_productive_author ($highest_avg lines/commit)"
  fi

  local total_contributors=$(echo "$stats" | wc -l)
  echo -e "${BLUE}Total Contributors:${NC} $total_contributors"
}
#function to display git graph
pretty_git_log() {
  git log --graph \
    --abbrev-commit \
    --decorate \
    --date=short \
    --format="%C(auto)%h%Creset %C(blue)%ad%Creset %C(green)%an%Creset %C(yellow)%d%Creset %Creset%s" \
    --all
}

# Check if environment variables are set
if [[ -z "$GITHUB_USER" ]]; then
  print_warning "GITHUB_USER environment variable is not set!"
  print_status "Please add this to your ~/.bashrc or ~/.zshrc:"
  print_status "  export GITHUB_USER=\"your_github_username\""
  exit 1
fi

if [[ -z "$GITHUB_TOKEN" ]]; then
  print_warning "GITHUB_TOKEN environment variable is not set!"
  print_status "Please add this to your ~/.bashrc or ~/.zshrc:"
  print_status "  export GITHUB_TOKEN=\"your_github_token\""
  exit 1
fi

while true; do
  # echo "Choose your spell:"
  # echo "1) Init new repo"
  # echo "2) Add files"
  # echo "3) Commit changes"
  # echo "4) Push to remote"
  # echo "5) Pull latest changes"
  # echo "6) Create/switch branch"
  # echo "7) Set remote (via token)"
  # echo "8) Show status"
  # echo "9) Remove files/folders (rm)"
  # echo "10) Exit"
  # read -p "Enter choice: " -r choice
  # echo

  show_repo_status # <-- shows the status dashboard at the top

  # fzf menu
  choice=$(printf "%s\n" \
    "Init new repo" \
    "Add files" \
    "Commit changes" \
    "Push to remote" \
    "Pull latest changes" \
    "Create/switch branch" \
    "Set remote (via token)" \
    "Show status" \
    "Contributor Statistics" \
    "Git graph" \
    "Remove files/folders (rm)" \
    "Merge branches" \
    "Uninitialize repo" \
    "Revert commit(s)" \
    "Exit" |
    fzf --prompt="Choose your spell: " --height=19 --border --ansi)

  echo

  case "$choice" in
  "Init new repo")
    read -p "Enter repo directory name (or '.' for current dir): " -r dirname
    if [[ "$dirname" == "." ]]; then
      git init
      print_status "Repo initialized in current directory: $(pwd)"
    else
      mkdir -p "$dirname" && cd "$dirname" || exit
      git init
      print_status "Repo initialized in new directory: $dirname"
      cd - >/dev/null 2>&1 || exit
    fi

    current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    if [[ "$current_branch" == "master" ]]; then
      git branch -M main
      print_status "Default branch renamed from 'master' to 'main'"
    fi
    ;;
    # "Add files")
    #  # Show untracked + modified files, plus an [ALL] option
    #  files=$( (
    #    echo "[ALL]"
    #    git ls-files --others --modified --exclude-standard
    #  ) |
    #    fzf --multi --prompt="Select files to add: " --height=15 --border)
    #
    #  if [[ -z "$files" ]]; then
    #    print_warning "No files selected."
    #  else
    #    if [[ "$files" == "[ALL]" ]]; then
    #      git add .
    #      print_status "All files staged."
    #    else
    #      git add $files
    #      print_status "Files staged: $files"
    #    fi
    #  fi
    #  ;;
  "Add files")
    # Define a preview command that uses bat/batcat and handles the [ALL] case
    preview_command="if [[ {} == '[ALL]' ]]; then 
                         git diff --color=always; 
                     else 
                         (bat --color=always --line-range :40 {} || batcat --color=always --line-range :40 {} || cat {}) 2>/dev/null;
                     fi"

    # Show untracked + modified files, plus an [ALL] option
    files=$( (
      echo "[ALL]"
      git ls-files --others --modified --exclude-standard
    ) |
      fzf --multi --prompt="Select files to add: " --height=20 --border \
        --preview "$preview_command" \
        --preview-window 'right:60%:border-left')

    if [[ -z "$files" ]]; then
      print_warning "No files selected."
    else
      # fzf returns selected items separated by newlines.
      # We need to handle the case where [ALL] is selected along with other files.
      if echo "$files" | grep -q "\[ALL\]"; then
        git add .
        print_status "All files staged."
      else
        # Use xargs to pass the file list to git add. This handles filenames with spaces.
        echo "$files" | xargs git add
        print_status "Files staged."
        # Optionally, list the files that were staged
        echo "$files"
      fi
    fi
    ;;
  "Commit changes")
    read -p "Enter commit message: " -r msg
    git commit -m "$msg"
    print_status "Commit done!"
    ;;
  "Push to remote")
    branch=$(git symbolic-ref --short HEAD 2>/dev/null)
    branch=${branch:-main}

    remote=$(git remote 2>/dev/null)
    if [[ -z "$remote" ]]; then
      print_error "No remote set!"
      read -p "Enter repo name (example: my-repo.git): " -r reponame
      remote_url="https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/${reponame}"
      git remote add origin "$remote_url"
      print_status "ðŸ”— Remote 'origin' set to $remote_url"
      remote="origin"
    fi

    echo "Pushing branch '$branch' to '$remote'..."
    git push -u "$remote" "$branch"
    ;;
  "Pull latest changes")
    read -p "Enter branch to pull (default main): " -r branch
    branch=${branch:-main}

    remote=$(git remote 2>/dev/null)
    if [[ -z "$remote" ]]; then
      print_error "No remote set! Cannot pull."
    else
      git pull "$remote" "$branch"
    fi
    ;;
  "Create/switch branch")
    # Show current branch and all available branches
    current_branch=$(get_current_branch)
    print_status "Current branch: $current_branch"
    echo
    print_status "Available branches:"
    show_branches
    echo

    # Let user choose between existing branches or new branch
    branch_option=$(printf "%s\n" \
      "Switch to existing branch" \
      "Create new branch" |
      fzf --prompt="Choose action: " --height=10 --border)

    case "$branch_option" in
    "Switch to existing branch")
      # Use fzf to select from existing branches
      existing_branch=$(git branch --format='%(refname:short)' | fzf --prompt="Select branch to switch to: " --height=10 --border --header="Current: $current_branch")
      if [[ -n "$existing_branch" ]]; then
        git checkout "$existing_branch"
        print_status "Switched to branch: $existing_branch"
      else
        print_warning "No branch selected."
      fi
      ;;
    "Create new branch")
      read -p "Enter new branch name: " -r new_branch
      if [[ -n "$new_branch" ]]; then
        git checkout -b "$new_branch"
        print_status "Created and switched to new branch: $new_branch"
      else
        print_error "No branch name provided."
      fi
      ;;
    *)
      print_warning "Operation cancelled."
      ;;
    esac
    ;;
  "Set remote (via token)")
    read -p "Enter repo name (example: my-repo.git): " -r reponame
    remote_url="https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/${reponame}"
    git remote remove origin 2>/dev/null
    git remote add origin "$remote_url"
    echo "Remote 'origin' set to $remote_url"
    ;;
  "Show status")
    git status
    ;;
    # "Remove files/folders (rm)")
    #   # List tracked + untracked files for removal
    #   files=$(git ls-files --cached --others --exclude-standard |
    #     fzf --multi --prompt="Select files to remove: " --height=15 --border)
    #
    #   if [[ -z "$files" ]]; then
    #     print_warning "No files selected."
    #     continue
    #   fi
    #
    #   echo "Files selected for removal:"
    #   echo "$files"
    #   echo
    #   read -p "Confirm removal? (y/N): " -r confirm
    #   if [[ "$confirm" =~ ^[Yy]$ ]]; then
    #     # Try removing from git first, fallback to filesystem
    #     for f in $files; do
    #       if git ls-files --error-unmatch "$f" >/dev/null 2>&1; then
    #         git rm -rf "$f"
    #       else
    #         rm -rf "$f"
    #       fi
    #     done
    #     print_status "Files removed: $files"
    #   else
    #     print_status "Operation cancelled."
    #   fi
    #   ;;
  "Remove files/folders (rm)")
    # List tracked + untracked files for removal
    files=$(git ls-files --cached --others --exclude-standard |
      fzf --multi --prompt="Select files/folders to remove: " --height=20 --border \
        --preview "(bat --color=always --line-range :50 {} || batcat --color=always --line-range :50 {} || head -n 50 {}) 2>/dev/null" \
        --preview-window 'right:60%:border-left')

    if [[ -z "$files" ]]; then
      print_warning "No files selected."
      continue # Use continue to go back to the main menu
    fi

    echo "Files selected for removal:"
    # Use 'tput' for better visual separation and color
    tput setaf 3
    echo "$files"
    tput sgr0
    echo

    read -p "Confirm removal? This cannot be undone. (y/N): " -r confirm
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      # Use a 'while read' loop to correctly handle filenames with spaces
      echo "$files" | while read -r f; do
        if [[ -z "$f" ]]; then continue; fi # Skip empty lines

        # Check if the file is tracked by git
        if git ls-files --error-unmatch "$f" >/dev/null 2>&1; then
          # It's a tracked file, use 'git rm'
          git rm -rf "$f"
        else
          # It's an untracked file, use 'rm'
          rm -rf "$f"
        fi
      done
      print_status "Selected files/folders have been removed."
    else
      print_status "Operation cancelled."
    fi
    ;;
  "Uninitialize repo")
    print_warning "This will completely uninitialize the Git repository in this folder."
    echo "This action will delete the .git directory and cannot be undone!"
    echo
    read -r -p "Are you sure you want to continue? (yes/no): " confirm_uninit

    if [[ "$confirm_uninit" == "yes" ]]; then
      if [ -d ".git" ]; then
        rm -rf .git
        print_status "Git repository has been uninitialized."
      else
        print_error "No .git directory found here. Nothing to do."
      fi
    elif [[ "$confirm_uninit" == "no" ]]; then
      print_status "Operation cancelled."
    else
      print_error "Invalid choice. Please type 'yes' or 'no'."
    fi
    ;;
  "Exit")
    echo "Git Wizard vanishes in a puff of smoke..."
    exit 0
    ;;
  "Merge branches")
    current_branch=$(get_current_branch)
    print_status "You are on branch: $current_branch"
    echo

    # Pick branch to merge from
    merge_branch=$(git branch --format='%(refname:short)' |
      grep -v "^$current_branch\$" |
      fzf --prompt="Select branch to merge into $current_branch: " --height=10 --border)

    if [[ -z "$merge_branch" ]]; then
      print_warning "No branch selected. Merge cancelled."
    else
      echo "Merging branch '$merge_branch' into '$current_branch'..."
      if git merge "$merge_branch"; then
        print_status "Merge successful!"
      else
        print_error "Merge had conflicts! Resolve them manually."
      fi
    fi
    ;;
  "Contributor Statistics")
    show_contributor_stats
    ;;

  "Revert commit(s)")
    print_status "Fetching commit history..."
    echo

    # Show commits as "<hash> <message>" but keep hash separately
    commits=$(git log --oneline --decorate |
      fzf --multi --ansi --height=20 --border \
        --prompt="Select commit(s) to revert: " \
        --header="Use TAB to select multiple commits" |
      awk '{print $1}')

    if [[ -z "$commits" ]]; then
      print_warning "No commit selected. Revert cancelled."
      continue
    fi

    echo "You selected:"
    echo "$commits"
    echo
    read -p "Confirm revert? (y/N): " -r confirm

    if [[ "$confirm" =~ ^[Yy]$ ]]; then
      for c in $commits; do
        echo "Reverting commit $c..."
        if git revert --no-edit "$c"; then
          print_status "Commit $c reverted."
        else
          print_error "Conflict occurred while reverting $c!"
          echo "Please resolve conflicts, then run:"
          echo "  git revert --continue"
          break
        fi
      done
    else
      print_status "Revert cancelled."
    fi
    ;;

  "Git graph")
    color=${YELLOW}
    line1="Git graph"
    line2="[INFO] press 'q' to exit"

    echo -e "${color}â•­$(printf 'â”€%.0s' $(seq 1 30))â•®${NC}"
    printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" 28 "$line1"
    printf "${color}â”‚${NC} %-*s ${color}â”‚${NC}\n" 28 "$line2"
    echo -e "${color}â•°$(printf 'â”€%.0s' $(seq 1 30))â•¯${NC}"

    sleep 2
    pretty_git_log
    ;;

  *)
    print_error "Invalid choice! Try again."
    echo "Git Wizard vanishes in a puff of smoke..."
    break
    ;;
  esac
  echo
done

