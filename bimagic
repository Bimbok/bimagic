#!/bin/bash

echo "Welcome to the Git Wizard! Let's work some magic..."
echo

# Colors for output
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

# Function to get current branch with color
get_current_branch() {
    git branch --show-current 2>/dev/null || echo "main"
}

# Function to display branches with fzf
show_branches() {
    local current_branch=$(get_current_branch)
    
    # Get all branches and highlight current one
    git branch -a --format='%(refname:short)' | \
    while read -r branch; do
        if [[ "$branch" == "$current_branch" ]]; then
            echo -e "${GREEN}‚û§ $branch${NC} (current)"
        else
            echo "  $branch"
        fi
    done | sort -u
}

show_repo_status() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_warning "Not inside a git repository!"
        return
    fi

    local branch=$(get_current_branch)

    # Ahead/behind info
    local upstream=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
    local ahead behind
    if [[ -n "$upstream" ]]; then
        ahead=$(git rev-list --count "$upstream"..HEAD 2>/dev/null)
        behind=$(git rev-list --count HEAD.."$upstream" 2>/dev/null)
    else
        ahead=0
        behind=0
    fi

    # Working tree status
    if git diff --quiet 2>/dev/null && git diff --cached --quiet 2>/dev/null; then
        if git ls-files -u | grep -q .; then
            status="üî¥ ${RED}conflicts${NC}"
            color=$RED
        else
            status="üü¢ ${GREEN}clean${NC}"
            color=$GREEN
        fi
    else
        status="üü° ${YELLOW}uncommitted${NC}"
        color=$YELLOW
    fi

    echo
    echo -e "${color}===== REPO STATUS =====${NC}"
    echo -e "GITHUB USER: ${GREEN}$GITHUB_USER${NC}"
    echo -e "BRANCH: ${GREEN}$branch${NC}"
    echo -e "AHEAD: $ahead | BEHIND: $behind"
    echo -e "STATUS: $status"
    echo -e "${color}=======================${NC}"
}

# Check if environment variables are set
if [[ -z "$GITHUB_USER" ]]; then
    print_warning "GITHUB_USER environment variable is not set!"
    print_status "Please add this to your ~/.bashrc or ~/.zshrc:"
    print_status "  export GITHUB_USER=\"your_github_username\""
    exit 1
fi

if [[ -z "$GITHUB_TOKEN" ]]; then
    print_warning "GITHUB_TOKEN environment variable is not set!"
    print_status "Please add this to your ~/.bashrc or ~/.zshrc:"
    print_status "  export GITHUB_TOKEN=\"your_github_token\""
    exit 1
fi

while true; do
    # echo "Choose your spell:"
    # echo "1) Init new repo"
    # echo "2) Add files"
    # echo "3) Commit changes"
    # echo "4) Push to remote"
    # echo "5) Pull latest changes"
    # echo "6) Create/switch branch"
    # echo "7) Set remote (via token)"
    # echo "8) Show status"
    # echo "9) Remove files/folders (rm)"
    # echo "10) Exit"
    # read -p "Enter choice: " -r choice
    # echo

    clear
    show_repo_status   # <-- shows the status dashboard at the top

    # fzf menu
    choice=$(printf "%s\n" \
        "1) Init new repo" \
        "2) Add files" \
        "3) Commit changes" \
        "4) Push to remote" \
        "5) Pull latest changes" \
        "6) Create/switch branch" \
        "7) Set remote (via token)" \
        "8) Show status" \
        "9) Remove files/folders (rm)" \
        "10) Exit" \
        | fzf --prompt="Choose your spell: " --height=14 --border --ansi)

    echo

    case "$choice" in
        "1) Init new repo")
            read -p "Enter repo directory name (or '.' for current dir): " -r dirname
            if [[ "$dirname" == "." ]]; then
                git init
                print_status "Repo initialized in current directory: $(pwd)"
            else
                mkdir -p "$dirname" && cd "$dirname" || exit
                git init
                print_status "Repo initialized in new directory: $dirname"
                cd - > /dev/null 2>&1 || exit
            fi

            current_branch=$(git symbolic-ref --short HEAD 2>/dev/null)
            if [[ "$current_branch" == "master" ]]; then
                git branch -M main
                print_status "Default branch renamed from 'master' to 'main'"
            fi
            ;;
        "2) Add files")
            read -p "Enter files to add (or '.' for all): " -r files
            git add "$files"
            print_status "Files staged: $files"
            ;;
        "3) Commit changes")
            read -p "Enter commit message: " -r msg
            git commit -m "$msg"
            print_status "Commit done!"
            ;;
        "4) Push to remote")
            branch=$(git symbolic-ref --short HEAD 2>/dev/null)
            branch=${branch:-main}

            remote=$(git remote 2>/dev/null)
            if [[ -z "$remote" ]]; then
                print_error "No remote set!"
                read -p "Enter repo name (example: my-repo.git): " -r reponame
                remote_url="https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/${reponame}"
                git remote add origin "$remote_url"
                print_status "üîó Remote 'origin' set to $remote_url"
                remote="origin"
            fi

            echo "Pushing branch '$branch' to '$remote'..."
            git push -u "$remote" "$branch"
            ;;
        "5) Pull latest changes")
            read -p "Enter branch to pull (default main): " -r branch
            branch=${branch:-main}
            
            remote=$(git remote 2>/dev/null)
            if [[ -z "$remote" ]]; then
                print_error "No remote set! Cannot pull."
            else
                git pull "$remote" "$branch"
            fi
            ;;
        "6) Create/switch branch")
            # Show current branch and all available branches
            current_branch=$(get_current_branch)
            print_branch "Current branch: $current_branch"
            echo
            print_status "Available branches:"
            show_branches
            echo

            # Let user choose between existing branches or new branch
            branch_option=$(printf "%s\n" \
                "Switch to existing branch" \
                "Create new branch" \
                | fzf --prompt="Choose action: " --height=10 --border)

            case "$branch_option" in
                "Switch to existing branch")
                    # Use fzf to select from existing branches
                    existing_branch=$(git branch --format='%(refname:short)' | fzf --prompt="Select branch to switch to: " --height=10 --border --header="Current: $current_branch")
                    if [[ -n "$existing_branch" ]]; then
                        git checkout "$existing_branch"
                        print_status "Switched to branch: $existing_branch"
                    else
                        print_warning "No branch selected."
                    fi
                    ;;
                "Create new branch")
                    read -p "Enter new branch name: " -r new_branch
                    if [[ -n "$new_branch" ]]; then
                        git checkout -b "$new_branch"
                        print_status "Created and switched to new branch: $new_branch"
                    else
                        print_error "No branch name provided."
                    fi
                    ;;
                *)
                    print_warning "Operation cancelled."
                    ;;
            esac
            ;;
        "7) Set remote (via token)")
            read -p "Enter repo name (example: my-repo.git): " -r reponame
            remote_url="https://${GITHUB_TOKEN}@github.com/${GITHUB_USER}/${reponame}"
            git remote remove origin 2>/dev/null
            git remote add origin "$remote_url"
            echo "Remote 'origin' set to $remote_url"
            ;;
        "8) Show status")
            git status
            ;;
        "9) Remove files/folders (rm)")
            read -p "Enter files/folders to remove (supports wildcards like *): " -r files
            if [[ -z "$files" ]]; then
                print_error "No files specified!"
                continue
            fi
            
            # Safety check for dangerous patterns
            if [[ "$files" == "*" ]]; then
                print_warning "You're about to remove ALL files in the current directory!"
                read -p "Are you sure? Type 'yes' to confirm: " -r confirm
                if [[ "$confirm" != "yes" ]]; then
                    echo "Operation cancelled."
                    continue
                fi
            fi
            
            # Check if files exist before removing
            if ls "$files" >/dev/null 2>&1; then
                print_status "Files/folders to be removed:"
                ls -la "$files"
                echo
                read -p "Confirm removal? (y/N): " -r confirm
                if [[ "$confirm" =~ ^[Yy]$ ]]; then
                    # Check if we're in a git repository
                    if git rev-parse --git-dir > /dev/null 2>&1; then
                        echo "üóëÔ∏è  Removing from git tracking and filesystem..."
                        # Use git rm for tracked files, regular rm for untracked
                        git rm -rf "$files" 2>/dev/null || rm -rf "$files"
                        print_status "Files/folders removed from git and filesystem: $files"
                    else
                        echo "üóëÔ∏è  Removing from filesystem (not a git repo)..."
                        rm -rf "$files"
                        print_status "Files/folders removed from filesystem: $files"
                    fi
                else
                    print_status "Operation cancelled."
                fi
            else
                print_error "‚ùå No files/folders found matching: $files"
            fi
            ;;
        "10) Exit")
            echo "Git Wizard vanishes in a puff of smoke..."
            exit 0
            ;;
        *)
            print_error "Invalid choice! Try again."
            echo "Git Wizard vanishes in a puff of smoke..."
            break
            ;;
    esac

    echo
done